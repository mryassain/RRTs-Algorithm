#include "StdAfx.h"
#include "RRTBoxS.h"
#include "RRTTree.h"
#include <math.h>
#include <cmath>
#include <stdlib.h>
#include <cstdlib>
#include <iostream>
#include <iostream>
#include <cstdlib>
RRTBoxS::RRTBoxS(void)
{
	dim=0;
	PasU=0;
	MinEspacedeta=0;
	MaxEspacedeta=0;
	Boxs=NULL;
	poibetal=1;//1/3.0;
	poibetg=1;//3.0;
	poieps=1;//3.0;

}
RRTBoxS::RRTBoxS(int dm,double Pasu,double minEsacedeta,double maxEpacedeta)//,struct Vertexes *h)
{
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	dim=dm;
	PasU= Pasu;
	MinEspacedeta=minEsacedeta;
	MaxEspacedeta=maxEpacedeta;
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	this->VolumeTotal=1;
	double *tab;
	tab=new double[dm];
	for(int i=0;i<this->dim;i++)
	{
		tab[i]=MinEspacedeta;
		this->VolumeTotal*=abs(MaxEspacedeta-MinEspacedeta);
	}
	Origine=RRTVertexe();
	Origine.ModiftVertex(tab,dim);
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//tjrs mm probleme de lespace d'etat jai pri (min1=,min2=....=,minN)	
	Boxs=NULL;
	RRTBoxS::box *l;
	RRTBoxS::box *p;
	l=Boxs;
	p = new struct box;
	double *t;
	t=new double[dim];
	for(int i=0;i<dim;i++)t[i]=minEsacedeta;
	p->LowerVertex.ModiftVertex(t,dim);
	for(int i=0;i<dim;i++)t[i]=maxEpacedeta;
	p->UpperVertex.ModiftVertex(t,dim);
	p->suivant=l;
	Boxs=p;
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	this->poibetal=1/3.0;//a verifier
	this->poibetg=1/3.0;//a verifier
	this->poieps=1/3.0;//a verifier
//	TreAlgo=NULL;
}
RRTBoxS::~RRTBoxS(void)
{
	//delete [] Boxs;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////consultations/////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
int RRTBoxS::ConsultDim()
{
	return dim;
}
double RRTBoxS::ConsultPasU()
{
	return PasU;
}
double RRTBoxS::Consultmaxetat()
{
	return MaxEspacedeta;
}
double RRTBoxS::ConsultMinetat()
{
	return MinEspacedeta;
}
double RRTBoxS::ConsultStarDiscrepancyMin()
{
	return this->StarDiscrepancyMin;
}
double RRTBoxS::ConsultstarDiscrepancyMax()
{
	return this->StarDiscrepancyMax;
}
double RRTBoxS::ConsultDiscrAplus()
{
	return Boxs->DiscrAplus;
}
double RRTBoxS::ConsultDiscrAMoins()
{
	return Boxs->DiscrAMoins;
}
double RRTBoxS::ConsultPoidsPartition()
{
	return this->PoiOfpartitionMax;
}
double RRTBoxS::ConsultVolumeBox()
{
	return Boxs->VolumeBox;
}
double RRTBoxS::ConsultDisparityMax()
{
	return this->DisparityMax;
}
double RRTBoxS::ConsultDisparityMin()
{
	return this->DisparityMin;
}
RRTVertexe RRTBoxS::ConsultationMinGRRT()
{
	return this->minGRRT;
}
RRTVertexe RRTBoxS::ConsultationMaxGRRT()
{
	return this->maxGRRT;
}
RRTVertexe RRTBoxS::ConsultationMinKRRT()
{
	return this->minKRRT;
}
RRTVertexe RRTBoxS::ConsultationMaxKRRT()
{
	return this->maxKRRT;
}
RRTAlgorithmes RRTBoxS::ConsultAlgorithmes()
{
	return this->TreAlgo;
}
RRTBoxS::box * RRTBoxS::ConsultBoxs()
{
	return Boxs;
}

RRTVertexe &RRTBoxS::ConsultUpperVertexs()
{
	return Boxs->UpperVertex;
}
RRTVertexe & RRTBoxS:: ConsultLowerVertexs()
{
	return Boxs->LowerVertex;
}

int RRTBoxS::ConsultNbrOfVertexBplus()
{
	return this->Boxs->NbrOfVertexAplus;
}
int RRTBoxS::ConsultNbrOfVertexBmoins()
{
	return this->Boxs->NbrOfVertexAmoins;
}
double RRTBoxS::ConsultVolumTotal()
{
	return VolumeTotal;
}
double RRTBoxS::ConsultPoit()
{
	return this->PotG;
}

///////Modification les attributs/////////////////////////////////////////////////////////////////////
void RRTBoxS::ModifPoidsEpsilone(double eps)
{
	this->poieps=eps;
}
void RRTBoxS::ModifPoidsBetaLocal(double betl)
{
	this->poibetal=betl;
}
void RRTBoxS::ModifPoidsBetaGolabal(double betg)
{
	this->poibetg=betg;

}
void RRTBoxS::ModifDim(int d)
{
	dim=d;
}
void RRTBoxS::ModifPasU(double Pasu)
{
	PasU=Pasu;
}
void RRTBoxS::ModificationEspaceMax(double maxx)
{
	MaxEspacedeta=maxx;
}
void RRTBoxS::ModificationEspaceMin(double minn)
{
	MinEspacedeta=minn;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////CONSTRUCTION///////////BOXS
////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
void RRTBoxS::AjoutObjetAlgorithm(RRTAlgorithmes A)
{
	TreAlgo=RRTAlgorithmes();//construction de la lago
	RRTTree::Vertexes *l;
	l=A.ConsultTrees().ConsultVertexes();
	while(l!=NULL)
	{
		TreAlgo.ModiftRRTreesOfAlgo(l->vertex);
		l=l->suivant;
	}	
}             
void RRTBoxS::CalculMesureOfDiscrpency(int kNbreOfvertex,RRTAlgorithmes A)
{
	this->NbrOfIteration=kNbreOfvertex;

	RRTBoxS::box *b;
	b=this->Boxs;

	RRTTree::Vertexes *l,*p;
	l=A.ConsultTrees().ConsultVertexes();

	while(b!=NULL)
	{
		p=l;
		RRTBoxS::box &bk=*b;
		int j=1;
		while( p!=NULL && j<=kNbreOfvertex)
		{
			//IsInBox(p->vertex,bk);
			p=p->suivant;
			j++;
		}

		b->MCVmax1 = ((double)b->NbrOfVertexAplus/this->NbrOfIteration) - (b->VolumeBmoins/this->VolumeTotal);
		
		b->MCVmax2 = (b->volumeBplus/this->VolumeTotal) - ((double)b->NbrOfVertexAmoins/this->NbrOfIteration);
		
		b->MCVmin1 = abs(((double)b->NbrOfVertexAplus/this->NbrOfIteration) - (b->volumeBplus/this->VolumeTotal));
		
		b->MCVmin2 = abs(((double)b->NbrOfVertexAmoins/this->NbrOfIteration) - (b->VolumeBmoins/this->VolumeTotal));	
		
		b->DiscrAplus = max(b->MCVmax1,b->MCVmax2);
		
		b->DiscrAMoins = max(b->MCVmin1,b->MCVmin2);
		
		b=b->suivant;
	}
}
void RRTBoxS::GeneralBoxsForRRT(RRTAlgorithmes A,int kNbreOfvertex)
{
	if(kNbreOfvertex==1)
	{
		PartitionOfBoxs();//bien fai
		CalculVolumeS();//verifier
		AjoutObjetAlgorithm(A);//verifier
	}
	InitialiserBoxsForRRT();// inclu dans la fct calcul pour reduire le temps dexecu
	CalculMesureOfDiscrpency(kNbreOfvertex);//sale d'operation
	StarDiscrepancy();//inclu dans la fct calcul pour reduire le temps dexecu
}
////////////////////////////////////////////////////////////
void RRTBoxS::PartitionOfBoxs()
{
	///////////////////////////////////////////////////////////////////////////////////////////////////////
	RRTBoxS::box *l;//////////////////////////////////////////////////////////////////////////////////////
	RRTVertexe uper2,lower2,uper1,lower1;/////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	uper2=RRTVertexe();///////////////////////////////////////////////////////////////////////////////////
	lower2=RRTVertexe();//////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	uper1=RRTVertexe();//////////////////////////////////////////////////////////////////////////////////
	lower1=RRTVertexe();/////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	double dt=0;/////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////

	for(int i=0;i<dim;i++)
	{
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		l=Boxs;//////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////

		while(l!=NULL)
		{
			if(abs((l->UpperVertex.ConsultVertex()[i])-(l->LowerVertex.ConsultVertex()[i]))>PasU)
			{
				////////////////////////////////////////////////////////////////////////////////////////////
				lower1.ModiftVertex(l->LowerVertex.ConsultVertex(),dim);///////////////////////////////////
				lower2.ModiftVertex(l->LowerVertex.ConsultVertex(),dim);/////////////////////////////////////
				uper1.ModiftVertex(l->UpperVertex.ConsultVertex(),dim);/////////////////////////////////////
				uper2.ModiftVertex(l->UpperVertex.ConsultVertex(),dim);/////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////
				
                //changement de la ieme element en cours un peti probleme de division sur un entier /////////////////////
				dt=l->LowerVertex.ConsultVertex()[i]+abs((l->LowerVertex.ConsultVertex()[i]-l->UpperVertex.ConsultVertex()[i])/2.0);
				uper1.ModifVertex(dt,i);////////////////////////////////////////////////////////////////////////////////////////
				lower2.ModifVertex(dt,i);///////////////////////////////////////////////////////////////////////////////////////
				//////////////////////////////////////////////////////////////////////////////////////////////////////////
				
				////////////////////////////////////////////////////////////////////////////////////////////////////////
				l->LowerVertex.ModifVertex(lower2);////////////////////////////////////////////////////////////////////
				l->UpperVertex.ModifVertex(uper2);//////////////////////////////////////////////////////////////////////
				//fonction ajouter/////////////////////////////////////////////////////////////////////////////////////
				ajouterBox(lower1,uper1);///////////////////////////////////////////////////////////////////////////////
				l=Boxs;////////////////////////////////////////////////////////////////////////////////////////////////
				// une fonction pour partitionner : Partitionner(boxs choisis);// box=la tete de la liste et l aussi;
			}
			else l=l->suivant;
		}
	}

}// ca marche bien //100 PR 100//partion just 100%
void RRTBoxS::ajouterBox(RRTVertexe LowerVertex,RRTVertexe UpperVertex)
{
	RRTBoxS::box *l;
	RRTBoxS::box *p;
	l=Boxs;
	p = new struct box;
	p->LowerVertex=RRTVertexe();
	p->UpperVertex=RRTVertexe();
	p->LowerVertex.ModifVertex(LowerVertex);
	p->UpperVertex.ModifVertex(UpperVertex);
	p->suivant=l;
	Boxs=p;
}// ca marche bien pour lapartition
void RRTBoxS::CalculVolumeS()
{
	///////////////////////////////////////////////////////////////////////////
	RRTBoxS::box *p;//////////////////////////////////////////////////////////
	p=Boxs;///////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////
	//FILE* vol;//////////////////////////////////////////////////////////////
	//vol=fopen("vol.dat", "w");/////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////

	while(p!=NULL)
	{
		////////////////////////////////////////////////////////////////////////////////////////
		p->volumeBplus=CalculVolume(Origine,p->UpperVertex);////////////////////////////////////
		p->VolumeBmoins=CalculVolume(Origine,p->LowerVertex);///////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		p->PoidsPartition=(p->volumeBplus-p->VolumeBmoins)/VolumeTotal;///////////
		///////////////////////////////////////////////////////////////////////////////////////////
		//fprintf(vol, " %f ",p->LowerVertex.ConsultVertex()[0]);//////////////////////////////////
		//fprintf(vol, " %f ",p->LowerVertex.ConsultVertex()[1]);//////////////////////////////////
		//fprintf(vol, " %f ",p->UpperVertex.ConsultVertex()[0]);/////////////////////////////////
		//fprintf(vol, " %f ",p->UpperVertex.ConsultVertex()[1]);/////////////////////////////////
		//fprintf(vol, " %f ",p->volumeBplus);///////////////////////////////////////////////////
		//fprintf(vol, " %f ",p->VolumeBmoins);//////////////////////////////////////////////////
		//fprintf(vol, " %f \n",p->PoidsPartition);/////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////
		p=p->suivant;//////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////
	}
}//juste 100%
double RRTBoxS::CalculVolume(RRTVertexe a ,RRTVertexe b)
{
	////////////////////////////////////////////////////////////////////////////
	double V=1;/////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////

	for(int i=0;i<a.ConsultDim();i++)
	{
		///////////////////////////////////////////////////////////////////////
		V*=abs(b.ConsultVertex()[i]-a.ConsultVertex()[i]);/////////////////////
		///////////////////////////////////////////////////////////////////////
	}
	////////////////////////////////////////////////////////////////////////////
	return V;///////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////
} 
////////////////////////////////////////////////////////////////////////////////
void RRTBoxS::poidOfPartition()
{
	///////////////////////////////////////////////////////////////////
	RRTBoxS::box *p;//////////////////////////////////////////////////
	p=Boxs;//////////////////////////////////////////////////////////
	double maxpoi=p->PoidsPartition;///////////////////////////////////
	//////////////////////////////////////////////////////////////////
	while(p!=NULL)
	{
		/////////////////////////////////////////////////////////////////////////////////
		if(maxpoi<p->PoidsPartition)
		{
		/////////////////////////////////////////////////////////////////////////////////////
		maxpoi=p->PoidsPartition;////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////
		}
		/////////////////////////////////////////////////////////////////////////////////////////
		p=p->suivant;///////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////
	}
	//////////////////////////////////////////////////////////////////////////////////////////
	this->PoiOfpartitionMax=maxpoi;////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////
}
void RRTBoxS::StarDiscrepancy()
{
	/////////////////////////////////////////////////////////////////////////
	double k;////////////////////////////////////////////////////////////////
	struct box *l;////////////////////////////////////////////////////////////
	l=this->Boxs;/////////////////////////////////////////////////////////////
	//////4096///////////////////////////////////////////////////////////////
	double maxdisc=l->DiscrAplus;//////////////////////////////////////////
	double mindisc=l->DiscrAMoins;///////////////////////////////////////
	double maxpoi=l->PoidsPartition;/////////////////////////////////////
	/////////////////////////////////////////////////////////////////////
	while(l!=NULL)
	{
		//////////////////////////////////////////////////////////
		if(l->DiscrAplus>maxdisc)
		{
			////////////////////////////////////////////////////
			maxdisc=l->DiscrAplus;//////////////////////////////
			///////////////////////////////////////////////////
		}
		///////////////////////////////////////////////////////
		if(l->DiscrAMoins>mindisc)
		{
			////////////////////////////////////////////////
			mindisc=l->DiscrAMoins;////////////////////////////
			////////////////////////////////////////////////
		}
		///////////////////////////////////////////////////////
		if(maxpoi<l->PoidsPartition)
		{
			///////////////////////////////////////////////////
			maxpoi=l->PoidsPartition;/////////////////////////
			//////////////////////////////////////////////////
		}
		////////////////////////////////////////////////////////
		if(l->DiscrAplus-l->DiscrAMoins>l->PoidsPartition)
		{
			///////////////////////////////////////////////
			k=l->DiscrAplus-l->DiscrAMoins;///////////////
			//////////////////////////////////////////////
		}
		l=l->suivant;
	}
	//////////////////////////////////////////////////////////////
	this->StarDiscrepancyMax=maxdisc;///////////////////////////
	this->StarDiscrepancyMin=mindisc;///////////////////////////
	this->PoiOfpartitionMax=maxpoi;/////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	this->AvergStarDiscrepancyMax=((this->StarDiscrepancyMax+this->StarDiscrepancyMin)/2.0);////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	this->MesureOfcoverge=1-(this->AvergStarDiscrepancyMax);///////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////
}
////////////////////////////////////////////////////////////////////////////////
void RRTBoxS::IsInBox(RRTVertexe a,box &b)
{	/*
	int i=0;
	while(i<a.ConsultDim() && a.ConsultVertex()[i]<=b.UpperVertex.ConsultVertex()[i] && a.ConsultVertex()[i]>=Origine.ConsultVertex()[i])
	{i++;}
	if(i==a.ConsultDim()){++b.NbrOfVertexAplus;}
	i=0;
	while(i<a.ConsultDim() && a.ConsultVertex()[i]<=b.LowerVertex.ConsultVertex()[i] && a.ConsultVertex()[i]>=Origine.ConsultVertex()[i])
	{i++;}
	if(i==a.ConsultDim()){++b.NbrOfVertexAmoins;}
	i=0;
	while(i<a.ConsultDim() && a.ConsultVertex()[i]<=b.UpperVertex.ConsultVertex()[i] && a.ConsultVertex()[i]>=b.LowerVertex.ConsultVertex()[i])
	{i++;}
	if(i==a.ConsultDim()){++b.NbrOfVertex;}
*/	
///////////////////////////////////////////////////////////////////////////////////////////////////////
	bool vertPlus=true;/////////////////////////////////////////////////////////////////////////////////
	bool vertMoins=true;////////////////////////////////////////////////////////////////////////////////
	//bool vert=true;///////////////////////////////////////////////////////////////////////////////////
	for(int i=0;i<a.ConsultDim();i++)
	{
		if( a.ConsultVertex()[i]>b.UpperVertex.ConsultVertex()[i]||a.ConsultVertex()[i]<Origine.ConsultVertex()[i])
		{
			vertPlus=false;
			vertMoins=false;
			break;
		}
		if( a.ConsultVertex()[i]>b.LowerVertex.ConsultVertex()[i] || a.ConsultVertex()[i]<Origine.ConsultVertex()[i])
		{
			vertMoins=false;
		}
		/*
		if( a.ConsultVertex()[i]>b.UpperVertex.ConsultVertex()[i] || a.ConsultVertex()[i]<b.LowerVertex.ConsultVertex()[i] )
		{
			vert=false;
		}*/
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if(vertPlus){b.NbrOfVertexAplus++;}
	if(vertMoins){b.NbrOfVertexAmoins++;}
	//if(vert) {++b.NbrOfVertex;}
}
void RRTBoxS::IsInBox(RRTVertexe a)
{
	//////////////////////////////////////////////////////////////
	RRTBoxS::box *l;/////////////////////////////////////////////
	l=this->Boxs;///////////////////////////////////////////////
	/////////4096///////////////////////////////////////////////
	bool vertPlus;/////////////////////////////////////////////
	bool vertMoins;//////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	//////////////////////////////
	while(l!=NULL)
	{ 
		/////////////////////////////
		vertPlus=true;/////////////////////////////////////////////////////
		vertMoins=true;/////////////////////////////////////////////////////
		////////////////////////////////
		for(int i=0;i<a.ConsultDim();i++)
		{
			if((a.ConsultVertex()[i]>l->UpperVertex.ConsultVertex()[i])||( a.ConsultVertex()[i]<this->Origine.ConsultVertex()[i]))
			{
				vertPlus=false;
				vertMoins=false;
				break;//////////////////////////////////a verifier 
			}
			if((a.ConsultVertex()[i]>l->LowerVertex.ConsultVertex()[i])|| (a.ConsultVertex()[i]<Origine.ConsultVertex()[i]))
			{
				vertMoins=false;
			}
		}
		if(vertPlus)
		{
			l->NbrOfVertexAplus++;
		}
		if(vertMoins)
		{
			l->NbrOfVertexAmoins++;
		}		
		l=l->suivant;
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////// METHODE for RRT/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void RRTBoxS::InitialiserBoxs()
{
	RRTBoxS::box *l;
	l=this->Boxs;
	FILE* part;
	part=fopen("part.dat", "w");
	while (l!=NULL)
	{
		//l->NbrOfVertex=0;//fai
		l->NbrOfVertexAplus=0;//fai
		l->NbrOfVertexAmoins=0;//fai
		//l->NVplus=true;
		//l->NVmoins=true;	
		l->MCVmax1=0;//fait
		l->MCVmin1=0;//fait
		/////////////////////
		l->MCVmax2=0;//fait
		l->MCVmin2=0;//fait
		/////////////////////
		l->DiscrAplus=0;//fai
		l->DiscrAMoins=0;//fai
		//////////////////////
		l->Muc=0;//fai
		l->Mu0=0;//fai
		l->Mum=0;//fai
		///////////////////////
		l->Epsilone=0;//fonction potentiel pour la borne inferieur	
		l->betaGlobal=0;//fai
		l->betaLocal=0;//fai
		l->PotentielGenral=0;//fai
		l->PotentielGenralForKRRT=0;//fai
		l->NbrOfSequencePlusP=0;//fai double mission
		l->NbrOfSequenceMoinsP=0;//fai  double mission
		l->NbrOfSequencePlusQ=0;//fai  double mission
		l->NbrOfSequenceMoinsQ=0;
		  //double mission				
		l->MCVmax1Plus=0;//fai
		l->MCVmin1Moin=0;//fai

		l->DeltaPlus=0;//delta plus
		l->DeltaMoins=0;//delta moins
		
		l->DeltaDispartyPlus=0;
		l->DeltaDispartyMoins=0;

		l->MCVmax2Plus=0;//fai		
		l->MCVmin2Moin=0;//fai

		l->MesureOfdisparityPlus=0;//fai
		l->mesureOfdisparityMoins=0;//fai

		l->EpsiloneForDispartit=0;
		///////////////////////////////////////////////////////////////////
		fprintf(part, " %f ",l->LowerVertex.ConsultVertex()[0]);////////////
		fprintf(part, " %f \n",l->LowerVertex.ConsultVertex()[1]);///////////
		fprintf(part, " %f ",l->UpperVertex.ConsultVertex()[0]);////////////
		fprintf(part, " %f \n",l->UpperVertex.ConsultVertex()[1]);/////////
		///////////////////////////////////////////////////////////////////
		l=l->suivant;
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void RRTBoxS::InitialiserBoxsForRRT()
{
	RRTBoxS::box *l;
	l=this->Boxs;
	while (l!=NULL)
	{
		//////////////////////////////////////////////////////////////////////////////////
		l->NbrOfVertexAplus=0;///////////////////////////////////////////////////////////
		l->NbrOfVertexAmoins=0;//////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		l=l->suivant;
	}
}
void RRTBoxS::CalculMesureOfDiscrpency(int kNbreOfvertex)
{
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	this->NbrOfIteration=kNbreOfvertex;/////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////
	RRTBoxS::box *b;//////////////////////////////////////////////////////////////////////////////////
	b=Boxs;//////////////////////////////////////////////////////////////////////////////////////////
	RRTTree::Vertexes *l,*p;////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	l=this->TreAlgo.ConsultTrees().ConsultVertexes();///////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////
	while(b!=NULL)
	{
		////////////////////////////////////////////////
		p=l;///////////////////////////////////////////
		RRTBoxS::box &bk=*b;///////////////////////////
		int j=1;//////////////////////////////////////
		/////////////////////////////////////////////
		while( p!=NULL && j<=kNbreOfvertex)
		{
			IsInBox(p->vertex,bk);
			p=p->suivant;j++;
		}
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b->MCVmax1 = ((double)b->NbrOfVertexAplus/this->NbrOfIteration)-(b->VolumeBmoins/this->VolumeTotal);
		b->MCVmax2 = (b->volumeBplus/this->VolumeTotal)-((double)b->NbrOfVertexAmoins/this->NbrOfIteration);
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b->MCVmin1 = abs(((double)b->NbrOfVertexAplus/this->NbrOfIteration) - (b->volumeBplus/this->VolumeTotal));
		b->MCVmin2 = abs(((double)b->NbrOfVertexAmoins/this->NbrOfIteration) - (b->VolumeBmoins/this->VolumeTotal));	
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b->DiscrAplus = max(b->MCVmax1,b->MCVmax2);
		////////////////////////////////////////////
		b->DiscrAMoins = max(b->MCVmin1,b->MCVmin2);
		////////////////////////////////////////////
		b=b->suivant;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
void RRTBoxS::CalculMesureOfDiscrpency(RRTVertexe a,int kNbreOfvertex)
{
	double x,y,z,w;
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	this->NbrOfIteration=kNbreOfvertex;//////////////////////////////////////////////////////////////////////////
	RRTBoxS::box *b;////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	b=this->Boxs;///////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//this->IsInBox(a);
	while(b!=NULL)
	{
		////////////////////////////////////////////////////////////////////////////////////////////////////////
		//RRTBoxS::box &bk=*b;////////////////////////////////////////////////////////////////////////////////////
		//IsInBox(a,bk);///////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////borne supי
		x=(double)b->NbrOfVertexAplus/(double)this->NbrOfIteration;
		y=(double)b->VolumeBmoins/(double)this->VolumeTotal;
		z=(double)b->volumeBplus/(double)this->VolumeTotal;
		w=(double)b->NbrOfVertexAmoins/(double)this->NbrOfIteration;
		////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b->MCVmax1 =(x-y);////////////////////////////////////////////////////////////////////////////////////////////
	 	b->MCVmax2 = (z-w);///////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b->DiscrAplus =(max(b->MCVmax1,b->MCVmax2));	////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////borne inf
		b->MCVmin2 = (abs(w-y));/////////////////////////////////////////////////////////////////////////////////////
		b->MCVmin1 = (abs(x-z));////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b->DiscrAMoins =(max(b->MCVmin1,b->MCVmin2));////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////
		if(b->DiscrAplus-b->DiscrAMoins>b->PoidsPartition)
		{
			double k=3;////un problייייייייייייייייייייייייייייייייייייייייייייייייייייייייייm
		}
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b=b->suivant;
	}
}
double RRTBoxS::Tranc(double d)
{
	double k=(double)(((int)((d-floor(d))*1000))/1000)+floor(d);
	return k;
	
}
void RRTBoxS::GeneralBoxsForRRT(RRTVertexe a,int kNbreOfvertex)
{
	if(kNbreOfvertex==1)
	{
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		PartitionOfBoxs();//////////////////////////////////////////////////////////////////////////////////////bien fai
		CalculVolumeS();/////////////////////////////////////////////////////////////////////////////////////////verifier	
		InitialiserBoxs();///////////////////////////////////////////////////////////////////////////////////////verifier
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	IsInBox(a);
	CalculMesureOfDiscrpency(a,kNbreOfvertex);/////////////////////////////////////////////////////////////////////////
	StarDiscrepancy();/////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}
//////////////////////////////////////////////////////////////////////////
//////////for GRRT////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RRTBoxS::InitialiserBoxsForGRRT()
{
	/////////////4096///////////////////////////////////////////////////////////////////////////////////////////////
	RRTBoxS::box *l;////////////////////////////////////////////////////////////////////////////////////////////////
	l=this->Boxs;///////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	while (l!=NULL)
	{
        //l->NbrOfVertex=0;////////////////////////////////////////////////////////////////////////////::/fai
		l->NbrOfVertexAplus=0;////////////////////////////////////////////////////////////////////////////fai
		l->NbrOfVertexAmoins=0;///////////////////////////////////////////////////////////////////////////fai
		l->betaGlobal=0;////////////////////////////////////////////////////////////////////////////////
		l->betaLocal=0;/////////////////////////////////////////////////////////////////////////////:
		l->Epsilone=0;//////////////////////////////////////////////////////////////////////////////:
		l->PotentielGenral=0;//////////////////////////////////////////////////////////////////////////:
		l->DeltaMoins=0;////////////////////////////////////////////////////////////////////////////////////:
		l->DiscrAplus=0;///////////////////////////////////////////////////////////////////////////////////////
		l->AstarMoins=0;//////////////////////////////////////////////////////////////////////////////////////////:
		l->AstarPlus=0;/////////////////////////////////////////////////////////////////////////////////////////////:
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l=l->suivant;////////////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
}

void RRTBoxS::CalculMesureOfDiscrpence(RRTVertexe a,int kNbreOfvertex)
{
	///////////////////////////////////////////////////////////////////////////////////////////////////////
	IsInBox(a);/////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	RRTBoxS::box *b;///////////////////////////////////////////////////////////////////////////////////////
	b=Boxs;/////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////////
	this->NbrOfIteration=kNbreOfvertex;///////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////////////
	while(b!=NULL)
	{
		/////////////////////////////////////////////////////////////////////////////////////////borne sup
		b->MCVmax1=((double)b->NbrOfVertexAplus/(double)this->NbrOfIteration)-((double)b->VolumeBmoins/(double)this->VolumeTotal);
		b->MCVmax2=((double)b->volumeBplus/(double)this->VolumeTotal)-((double)b->NbrOfVertexAmoins/(double)this->NbrOfIteration);
		b->DiscrAplus=max(b->MCVmax1,b->MCVmax2);/////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////borne inf
		b->MCVmin1=abs(((double)b->NbrOfVertexAplus/(double)this->NbrOfIteration)-((double)b->volumeBplus/(double)this->VolumeTotal));
		b->MCVmin2=abs(((double)b->NbrOfVertexAmoins/(double)this->NbrOfIteration)-((double)b->VolumeBmoins/(double)this->VolumeTotal));
  		b->DiscrAMoins=max(b->MCVmin1,b->MCVmin2);//////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////
		b=b->suivant;////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////
	}
}
void RRTBoxS::CalculAstarPlusMoins(int kNbreOfvertex)
{
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	RRTBoxS::box *l;//////////////////////////////////////////////////////////////////////////////////////////////////////
	l=Boxs;///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////4096 boites/////////////////////////////////////////////////////////////////////////////////////////////////
	while(l!=NULL)
	{
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l->AstarPlus=(kNbreOfvertex)*(l->volumeBplus/VolumeTotal);///////////////////////////////////////////////////
		l->AstarMoins=(kNbreOfvertex)*(l->VolumeBmoins/VolumeTotal);////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l->DeltaPlus=l->NbrOfVertexAplus-l->AstarPlus;////////////////////////////////////////////////////
		l->DeltaMoins=l->NbrOfVertexAmoins-l->AstarMoins;//////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////
		l->Muc =l->NbrOfVertexAplus-l->AstarMoins;//////////////////////////////////////////////////////////
		l->Mu0 =l->AstarPlus-l->NbrOfVertexAmoins;/////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////
		l->Mum = max(l->Muc,l->Mu0);//////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l=l->suivant;/////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
}
void RRTBoxS::CalculFonctionPotentielBeta()
{
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	struct box *l;////////////////////////////////////////////////////////////////////////////////////////////////////////
	l=this->Boxs;//////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////4096/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////
	while(l!=NULL)
	{
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l->Epsilone=(double)(1-((double)l->DeltaPlus/(double)this->NbrOfIteration))/(1-((double)l->DeltaMoins/(double)this->NbrOfIteration));
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l->betaGlobal=StarDiscrepancyMax-((double)l->Mum/(double)this->NbrOfIteration);//////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l->betaLocal=(l->betaGlobal)*((double)abs((l->DeltaPlus)+(l->DeltaMoins))/(double)this->NbrOfIteration);/////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l->PotentielGenral=(this->poieps)*(l->Epsilone)+(this->poibetg)*(l->betaGlobal)+(this->poibetal)*(l->betaLocal);///
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l=l->suivant;////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
}
void RRTBoxS::SearchfctPotentiel()
{
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	struct box *l;/////////////////////////////////////////////////////////////////////////////////////////////////
	struct box *p;////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	l=this->Boxs;/////////////////////////////////////////////////////////////////////////////////////////////////
	p=this->Boxs;
	//////4096////////////////////////////////////////////////////////////////////////////////////////////////////
	maxGRRT=RRTVertexe();/////////////////////////////////////////////////////////////////////////////////////////
	minGRRT=RRTVertexe();/////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	double maxpot=l->PotentielGenral;///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	while(l!=NULL)
	{
		if(maxpot<l->PotentielGenral)
		{
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			p=l;////////////////////////////////////////////////////////////////////////////////////////////////////
			if(l==NULL||p==NULL)
			{
				int f=0;
			}
			maxpot=l->PotentielGenral;//////////////////////////////////////////////////////////////////////////////
		} 
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l=l->suivant;//////////////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	maxGRRT.ModifVertex(p->UpperVertex);
	minGRRT.ModifVertex(p->LowerVertex);
	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	if(maxGRRT.ConsultVertex()[0]>this->MaxEspacedeta||maxGRRT.ConsultVertex()[1]>this->MaxEspacedeta||minGRRT.ConsultVertex()[0]<this->MinEspacedeta||maxGRRT.ConsultVertex()[1]<this->MinEspacedeta)
	{
		int rg=1;
	}
	this->PotG=maxpot;
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//maxGRRT.ModifVertex(p->UpperVertex);////////////////////////////////////////////////////////////////a verifier
	//minGRRT.ModifVertex(p->LowerVertex);///////////////////////////////////////////////////////////////a verifier
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}
void RRTBoxS::GeneralBoxsForGRRTT(RRTVertexe a,int kNbreOfvertex)
{
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	this->NbrOfIteration=kNbreOfvertex;////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if(kNbreOfvertex==1)
	{
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		PartitionOfBoxs();///////////////////////////////////////////////////////////////////////////////////////////////
		CalculVolumeS();/////////////////////////////////////////////////////////////////////////////////////////////////
		InitialiserBoxsForGRRT();////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	CalculMesureOfDiscrpence(a,kNbreOfvertex-1);///////////////////////////////////////////////////////////////////////////
	StarDiscrepancy();/////// //////////////////////////////////////////////////////////////////////////////////////////
	CalculAstarPlusMoins(kNbreOfvertex);///////////////////////////////////////////////////////////////////////////////                      
	CalculFonctionPotentielBeta();  ////// ///////////////////////////////////////////////////////////////////////////     
	SearchfctPotentiel();/////////////////////////////////////////////////////////////////////////////////////////////////
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////DISPARITY/////&&////////////DISCREPENCY//////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RRTBoxS::RandomForSequence(int TailleOfsequenceQ,int TailleOfsequenceP)
{
	SequenceP=new RRTVertexe[TailleOfsequenceP];
	IdealSequenceOfHalton=new RRTVertexe[TailleOfsequenceQ];
	
	for(int j=0;j<TailleOfsequenceP;j++)
	{
		double *tab;
		tab=new double[this->dim];
		for (int i=0;i<this->dim;i++)
		{
			//tab[i]= min1 + (int) ((double) rand() / (RAND_MAX+1.0) * (max1-min1+1));
			tab[i]= this->MinEspacedeta + ((this->MaxEspacedeta - this->MinEspacedeta) * (rand () / (double) RAND_MAX));
		}
		SequenceP[j].ModiftVertex(tab,this->dim);
	}
/*The number I is input.
  The number H is output.

  H = 0
  half = 1 / 2

  do while ( I is not zero )
    digit = mod ( I, 2 )
    H = H + digit * half
    I = ( I - digit ) / 2
    half = half / 2
  end
 

function v=cpermutaion(n)
  v=1:n;
  d=n;
  while(n<>1)
    R1=grand(1,2,"uin",1,n);
    //R2=grand(1,1,"uin",1,n);
    s=v(R1(1));
    v(R1(1))= v(R1(2));
    v(R1(2))=s;
    n=n-1;
  end
  endfunction
*/
}
void RRTBoxS::CalculMesureOfDiscrpence(RRTTree::Vertexes *l,int kNbreOfvertex)
{
	RRTBoxS::box *b;
	b=Boxs;
	RRTTree::Vertexes *p;
	this->NbrOfIteration=kNbreOfvertex;
	while(b!=NULL)
	{
		p=l;
		RRTBoxS::box &bk=*b;
		int j=1;
		while((p!=NULL)&&(j<=kNbreOfvertex))
		{
			IsInBox(p->vertex,bk);
			p=p->suivant;
			j++;
		}
		b->MCVmax1=((double)b->NbrOfVertexAplus/this->NbrOfIteration)-(b->VolumeBmoins/this->VolumeTotal);
		b->MCVmax2=(b->volumeBplus/this->VolumeTotal)-((double)b->NbrOfVertexAmoins/this->NbrOfIteration);
		b->MCVmin1=abs(((double)b->NbrOfVertexAplus/this->NbrOfIteration)-(b->volumeBplus/this->VolumeTotal));
		b->MCVmin2=abs(((double)b->NbrOfVertexAmoins/this->NbrOfIteration)-(b->VolumeBmoins/this->VolumeTotal));
		b->DiscrAplus=max(b->MCVmax1,b->MCVmax2);
		b->DiscrAMoins=max(b->MCVmin1,b->MCVmin2);
		///////////////////////////////////////////
		b->DeltaPlus=(b->NbrOfVertexAplus)-(b->AstarPlus);
		b->DeltaMoins=(b->NbrOfVertexAmoins)-(b->AstarMoins);
		///////////////////////////////////////////
		b->Muc=(b->NbrOfVertexAplus)-b->AstarMoins;
		b->Mu0=b->AstarPlus-(b->NbrOfVertexAmoins);
		b->Mum=max(b->Muc,b->Mu0);
		b=b->suivant;
	}
}
void RRTBoxS::CalculMesureOfDiparity()
{
	RRTBoxS::box *b;
	b=Boxs;
	while(b!=NULL)
	{
		RRTBoxS::box &bk=*b;
		int j=0;
		while(j<this->TailleOfsequenceP)
		{
			IsInBoxDisparityP(this->SequenceP[j],bk);
			IsInBoxDisparityQ(this->IdealSequenceOfHalton[j++],bk);
		}
		b->MCVmax1Plus=((double)b->NbrOfSequencePlusP/(double)this->TailleOfsequenceP)-((double)b->NbrOfSequenceMoinsQ/(double)this->TailleOfsequenceQ);
		b->MCVmax2Plus=((double)b->NbrOfSequencePlusQ/(double)this->TailleOfsequenceQ)-((double)b->NbrOfSequenceMoinsP/(double)this->TailleOfsequenceP);
		b->MCVmin1Moin=abs((double)(b->NbrOfSequenceMoinsP/(double)this->TailleOfsequenceP)-((double)b->NbrOfSequenceMoinsQ/(double)this->TailleOfsequenceQ));
		b->MCVmin2Moin=abs((double)(b->NbrOfSequencePlusP/(double)this->TailleOfsequenceP)-((double)b->NbrOfSequencePlusQ/(double)this->TailleOfsequenceQ));
		b->MesureOfdisparityPlus=max(b->MCVmax1Plus,b->MCVmax2Plus);
		b->mesureOfdisparityMoins=max(b->MCVmin1Moin,b->MCVmin2Moin);
		b=b->suivant;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////refaire
void RRTBoxS::CalculMesureOfDiparity(RRTTree::Vertexes *Tre1,RRTTree::Vertexes *Tre2)
{
	RRTBoxS::box *b;
	b=Boxs;
	RRTTree::Vertexes *tre1;
	RRTTree::Vertexes *tre2;
	tre1=Tre1;
	tre2=Tre2;
	int tail1=0;
	int tail2=0;

	while(b!=NULL)
	{
		RRTBoxS::box &bk=*b;
		int j=0;
		while(tre1!=NULL)
		{
			IsInBoxDisparityP(tre1->vertex,bk);
			tail1++;	
			tre1=tre1->suivant;
		}
		while(tre2!=NULL)
		{
			IsInBoxDisparityQ(tre2->vertex,bk);
			tail2++;     //a faire
			tre2=tre2->suivant;
		}
		TailleOfsequenceP=tail1;
		TailleOfsequenceQ=tail2;
		b->MCVmax1Plus=((double)b->NbrOfSequencePlusP/(double)this->TailleOfsequenceP)-((double)b->NbrOfSequenceMoinsQ/(double)this->TailleOfsequenceQ);
		b->MCVmax2Plus=((double)b->NbrOfSequencePlusQ/(double)this->TailleOfsequenceQ)-((double)b->NbrOfSequenceMoinsP/(double)this->TailleOfsequenceP);
		b->MCVmin1Moin=abs((double)(b->NbrOfSequenceMoinsP/(double)this->TailleOfsequenceP)-((double)b->NbrOfSequenceMoinsQ/(double)this->TailleOfsequenceQ));
		b->MCVmin2Moin=abs((double)(b->NbrOfSequencePlusP/(double)this->TailleOfsequenceP)-((double)b->NbrOfSequencePlusQ/(double)this->TailleOfsequenceQ));
		b->MesureOfdisparityPlus=max(b->MCVmax1Plus,b->MCVmax2Plus);
		b->mesureOfdisparityMoins=max(b->MCVmin1Moin,b->MCVmin2Moin);
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b->EpsiloneForDispartit=(double)((double)1.0+b->MesureOfdisparityPlus/(double)1.0+b->mesureOfdisparityMoins);
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b=b->suivant;
	}


}


void RRTBoxS::IsInBoxDisparityP(RRTVertexe a,box &b)
{
	bool vertP=true;
	bool vertM=true;
	
	for(int i=0;i<a.ConsultDim();i++)
	{
		if((a.ConsultVertex()[i]>b.UpperVertex.ConsultVertex()[i])||(a.ConsultVertex()[i]<Origine.ConsultVertex()[i]))
		{
			vertP=false;
			vertM=false;
			break;
		}
		if((a.ConsultVertex()[i]>b.LowerVertex.ConsultVertex()[i])||(a.ConsultVertex()[i]<Origine.ConsultVertex()[i]))
		{
			vertM=false;
		}
	}
	if(vertP)++b.NbrOfSequencePlusP;
	if(vertM)++b.NbrOfSequenceMoinsP;
}
void RRTBoxS::IsInBoxDisparityQ(RRTVertexe a,box &b)
{
	bool vertP=true;
	bool vertM=true;
	
	for(int i=0;i<a.ConsultDim();i++)
	{
		if((a.ConsultVertex()[i]>b.UpperVertex.ConsultVertex()[i])||(a.ConsultVertex()[i]<Origine.ConsultVertex()[i]))
		{
			vertP=false;
			vertM=false;
			break;
		}
		if((a.ConsultVertex()[i]>b.LowerVertex.ConsultVertex()[i])||(a.ConsultVertex()[i]<Origine.ConsultVertex()[i]))
		{
			vertM=false;
		}
	}
	if(vertP)++b.NbrOfSequencePlusQ;
	if(vertM)++b.NbrOfSequenceMoinsQ;
}
void RRTBoxS::GeneralDisparity(int TailleOfsequenceQ,int TailleOfsequenceP)
{
	PartitionOfBoxs();
	CalculVolumeS();
	RandomForSequence(TailleOfsequenceQ,TailleOfsequenceP);
	CalculMesureOfDiparity();
	CalculDisparityMinMax();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RRTBoxS::IsInBoxDisparity(RRTVertexe a,bool v)
{
	//////////////////////////////////////////////////////////////
	RRTBoxS::box *l;/////////////////////////////////////////////
	l=this->Boxs;///////////////////////////////////////////////
	/////////4096///////////////////////////////////////////////
	bool vertPlusP;/////////////////////////////////////////////
	bool vertMoinsP;//////////////////////////////////////////////////
	bool vertPlusQ;/////////////////////////////////////////////
	bool vertMoinsQ;//////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////
	while(l!=NULL)
	{
		if(v)
		{
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			vertPlusP=true;//////////////////////////////////////////////////////
			vertMoinsP=true;/////////////////////////////////////////////////////
			/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			for(int i=0;i<a.ConsultDim();i++)
			{
				if((a.ConsultVertex()[i]>l->UpperVertex.ConsultVertex()[i])||(a.ConsultVertex()[i]<this->Origine.ConsultVertex()[i]))
				{
					//////////////////////////////////////////////////
					vertPlusP=false;//////////////////////////////////
					vertMoinsP=false;/////////////////////////////////
					break;//////////////////////////////////a verifier 
				}
				if((a.ConsultVertex()[i]>l->LowerVertex.ConsultVertex()[i])|| (a.ConsultVertex()[i]<Origine.ConsultVertex()[i]))
				{
					//////////////////////////////////////////////////
					vertMoinsP=false;/////////////////////////////////
					//////////////////////////////////////////////////
				}
			}
			if(vertPlusP)
			{
				///////////////////////////////////////////////////////
				l->NbrOfSequencePlusP++;///////////////////////////////
				///////////////////////////////////////////////////////
			}
			if(vertMoinsP)
			{
				///////////////////////////////////////////////////////
				l->NbrOfSequenceMoinsP++;//////////////////////////////
				///////////////////////////////////////////////////////
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		else
		{
			////////////////////////////////////////////////////////////////////
			vertPlusQ=true;/////////////////////////////////////////////////////
			vertMoinsQ=true;////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////
			for(int i=0;i<a.ConsultDim();i++)
			{
				if((a.ConsultVertex()[i]>l->UpperVertex.ConsultVertex()[i])||(a.ConsultVertex()[i]<this->Origine.ConsultVertex()[i]))
				{
					//////////////////////////////////////////////////
					vertPlusQ=false;//////////////////////////////////
					vertMoinsQ=false;/////////////////////////////////
					break;//////////////////////////////////a verifier
					//////////////////////////////////////////////////
				}
				if((a.ConsultVertex()[i]>l->LowerVertex.ConsultVertex()[i])|| (a.ConsultVertex()[i]<Origine.ConsultVertex()[i]))
				{
					///////////////////////////////////////////////////
					vertMoinsQ=false;//////////////////////////////////
					///////////////////////////////////////////////////
				}
			}
			if(vertPlusQ)
			{
				///////////////////////////////////////////////////////////
				l->NbrOfSequencePlusQ++;///////////////////////////////////
				///////////////////////////////////////////////////////////
			}
			if(vertMoinsQ)
			{
				//////////////////////////////////////////////////////////
				l->NbrOfSequenceMoinsQ++;/////////////////////////////////
				//////////////////////////////////////////////////////////
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l=l->suivant;///////////////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
}

void RRTBoxS::CalculMesureOfDiparity(RRTVertexe a,bool v)
{
	/////////////////////////////////////////////////////////////////////////////
	double x,y,z,w;//////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////
	RRTBoxS::box *b;/////////////////////////////////////////////////////////////
	b=this->Boxs;////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	IsInBoxDisparity(a,v);///////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////
	if(v)
	{
		////////////////////////////////////////////////////////////////////////
		this->TailleOfsequenceP++;//////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
	}
	else 
	{
		///////////////////////////////////////////////////////////////////////
		this->TailleOfsequenceQ++;/////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////
	}
	while(b!=NULL)
	{
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b->MCVmax1Plus=((double)b->NbrOfSequencePlusP/(double)this->TailleOfsequenceP)-((double)b->NbrOfSequenceMoinsQ/(double)this->TailleOfsequenceQ);
		b->MCVmax2Plus=((double)b->NbrOfSequencePlusQ/(double)this->TailleOfsequenceQ)-((double)b->NbrOfSequenceMoinsP/(double)this->TailleOfsequenceP);
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b->MCVmin1Moin=abs((double)(b->NbrOfSequenceMoinsP/(double)this->TailleOfsequenceP)-((double)b->NbrOfSequenceMoinsQ/(double)this->TailleOfsequenceQ));
		b->MCVmin2Moin=abs((double)(b->NbrOfSequencePlusP/(double)this->TailleOfsequenceP)-((double)b->NbrOfSequencePlusQ/(double)this->TailleOfsequenceQ));
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b->MesureOfdisparityPlus=max(b->MCVmax1Plus,b->MCVmax2Plus);///////////////////////////////////////////////////////////////////////////////////////////
		b->mesureOfdisparityMoins=max(b->MCVmin1Moin,b->MCVmin2Moin);//////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		b=b->suivant;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
}
void RRTBoxS::CalculDisparityMinMax()
{
	////////////////////////////////////////////////////////////////////////////////////////////////////
	RRTBoxS::box *p;////////////////////////////////////////////////////////////////////////////////////
	p=this->Boxs;///////////////////////////////////////////////////////////////////////////////////////
	double max=p->MesureOfdisparityPlus;////////////////////////////////////////////////////////////////
	double min=p->mesureOfdisparityMoins;///////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////
	while(p!=NULL)
	{
		if(max<p->MesureOfdisparityPlus)
		{
			////////////////////////////////////////////////////////////////////////////////////////////
			max=p->MesureOfdisparityPlus;///////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////
		}
		if(min<p->mesureOfdisparityMoins)
		{
			///////////////////////////////////////////////////////////////////////////////////////////
			min=p->mesureOfdisparityMoins;/////////////////////////////////////////////////////////////
			///////////////////////////////////////////////////////////////////////////////////////////
		}
		///////////////////////////////////////////////////////////////////////////////////////////////
		p=p->suivant;//////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////
	this->DisparityMin=min;////////////////////////////////////////////////////////////////////////////
	this->DisparityMax=max;////////////////////////////////////////////////////////////////////////////
	this->AverageDIsparity=(min+max)/(double)2.0;//////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////
}
void RRTBoxS::CalculNouvelleMesure()
{
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	double CoefKRRTR=1/2.0;//////////////////////////////////////////////////////////////////////////////
	double CoefKRRT=1/2.0;///////////////////////////////////////////////////////////////////////////////
	struct box *l;///////////////////////////////////////////////////////////////////////////////////////
	l=this->Boxs;//////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	while(l!=NULL)
	{
		/////////////////////////////////////////////////////////////////////////////////////////////////
		l->PotentielGenralForKRRT=(CoefKRRTR*l->PotentielGenral)+(CoefKRRT*l->EpsiloneForDispartit);/////
		l=l->suivant;////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////
	}
}
/*void RRTBoxS::PotentielDisparity()
{


	///////////////////////////////en cours/////////////////////////////////////////////////////////

}*/
void RRTBoxS::SearchfctPotentielforKRRT()
{
	/////////////////////////////////////////////////////////////////////
	struct box *l;///////////////////////////////////////////////////////
	struct box *p;///////////////////////////////////////////////////////
	l=Boxs;//////////////////////////////////////////////////////////////
	p=Boxs;//////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////
	maxKRRT=RRTVertexe();////////////////////////////////////////////////
	minKRRT=RRTVertexe();////////////////////////////////////////////////
	double maxpot=l->PotentielGenralForKRRT;/////////////////////////////
	this->maxKRRT=l->UpperVertex;////////////////////////////////////////
	this->minKRRT=l->LowerVertex;////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////
	while(l!=NULL)
	{
		if(maxpot<l->PotentielGenralForKRRT)
		{
			/////////////////////////////////////////////////////////////
			p=l;/////////////////////////////////////////////////////////
			maxpot=l->PotentielGenralForKRRT;////////////////////////////
			/////////////////////////////////////////////////////////////
		}
		/////////////////////////////////////////////////////////////////
		l=l->suivant;////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////
	}
	/////////////////////////////////////////////////////////////////////
	maxKRRT=p->UpperVertex;//////////////////////////////////////////////
	minKRRT=p->LowerVertex;//////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////
}
//////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////mesure de couverture////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void RRTBoxS::GeneralBoxsForGRRT(RRTTree::Vertexes *l,int kNbreOfvertex)
{
	if(kNbreOfvertex==1)
	{
		PartitionOfBoxs();//cjuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuust 100%
		CalculVolumeS();//c juuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuust 100%
		CalculAstarPlusMoins(kNbreOfvertex);//c bon
	}
	else InitialiserBoxsForGRRT();              //inclu dans la fonction calcul pour reduire le temps d'exיcu
	CalculMesureOfDiscrpence(l,kNbreOfvertex); ////inclu dans la fonction calcul pour reduire le temps dexי
	StarDiscrepancy();                        //de mmmmmm pour une while
	CalculFonctionPotentielBeta();           //de mmmmmm pour une seule while
	SearchfctPotentiel();                   //return les bornes sup et inf de la boit potentiel
}
int RRTBoxS::chercheBoite()
{
	RRTBoxS::box *l;
	l=this->Boxs;
	int vrai=0;

	while(l!=NULL)
	{
		if(l->NbrOfVertexAplus>0)
		{
			++vrai; 
		}
		l=l->suivant;
	}
	return vrai;
}
void RRTBoxS::StarDiscrepancancy(RRTVertexe *xgoals,int k)
{
	RRTBoxS::box *b;
	b=Boxs;
	/////////////////////////////////////////
	/////////////////////////////////////////
	this->NbrOfIteration=k;
	for(int i=0;i<k;i++)
	{
		this->IsInBox(xgoals[i]);
	}
	while(b!=NULL)
		{
		////////////////////////////////////////////borne sup
		b->MCVmax1=((double)b->NbrOfVertexAplus/this->NbrOfIteration)-(b->VolumeBmoins/this->VolumeTotal);
		b->MCVmax2=(b->volumeBplus/this->VolumeTotal)-((double)b->NbrOfVertexAmoins/this->NbrOfIteration);
		b->DiscrAplus=max(b->MCVmax1,b->MCVmax2);
		//////////////////////////////////////////////borne inf
		b->MCVmin1=abs(((double)b->NbrOfVertexAplus/this->NbrOfIteration)-(b->volumeBplus/this->VolumeTotal));
		b->MCVmin2=abs(((double)b->NbrOfVertexAmoins/this->NbrOfIteration)-(b->VolumeBmoins/this->VolumeTotal));
  		b->DiscrAMoins=max(b->MCVmin1,b->MCVmin2);	
		///////////////////////////////////////////////////////////////		
		//////////////////////////////////////////////////////////////
		b=b->suivant;
		}
}
double RRTBoxS::Star()
{
	struct box *l;
	l=this->Boxs;
	/////////////////////////////////
	//////4096////////////////////
	//////////////////////////////
	double maxdisc=l->DiscrAplus;
	double mindisc=l->DiscrAMoins;
	double maxpoi=l->PoidsPartition;

	while(l!=NULL)
	{
		///////////////////////////////////////////////////////////
		if(l->DiscrAplus > maxdisc){maxdisc=l->DiscrAplus;}
		if(l->DiscrAMoins > mindisc){mindisc=l->DiscrAMoins;}
		if(maxpoi < l->PoidsPartition){maxpoi=l->PoidsPartition;}
		///////////////////////////////////////////////////////////
		if(l->DiscrAplus-l->DiscrAMoins > l->PoidsPartition)
		{
			int k=123;
		}
		l=l->suivant;
	}
	////////////////////////////////////
	this->StarDiscrepancyMax = maxdisc;
	this->StarDiscrepancyMin = mindisc;
	this->PoiOfpartitionMax = maxpoi;
	///////////////////////////////////
	this->AvergStarDiscrepancyMax = ((this->StarDiscrepancyMax+this->StarDiscrepancyMin)/2.0);
	///////////////////////////////////////
	this->MesureOfcoverge = 1-(this->AvergStarDiscrepancyMax);
	return this->AvergStarDiscrepancyMax;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////limites boites/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RRTBoxS::BoiteLimites()
{
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	int nblimite=0;////////////////////////////////////////////////////////////////////////////////////////////////
	RRTBoxS::box *l;///////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	l=this->Boxs;////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	while (l!=NULL)
	{
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l->boiteLimite=false;//////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		if((l->LowerVertex.ConsultVertex()[0]==this->MinEspacedeta)||(l->LowerVertex.ConsultVertex()[1]==this->MinEspacedeta))
		{
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			l->boiteLimite=true;////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
		}
		if((l->UpperVertex.ConsultVertex()[0]==this->MaxEspacedeta)||(l->UpperVertex.ConsultVertex()[1]==this->MaxEspacedeta))
		{
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			l->boiteLimite=true;////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l=l->suivant;///////////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
}

void RRTBoxS::GeneralBoxsForRRTTLimit(RRTVertexe a,int kNbreOfvertex)
{
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	this->NbrOfIteration=kNbreOfvertex;////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if(kNbreOfvertex<3000)
	{
		if(kNbreOfvertex==1)
		{
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		PartitionOfBoxs();///////////////////////////////////////////////////////////////////////////////////////////////
		CalculVolumeS();/////////////////////////////////////////////////////////////////////////////////////////////////
		InitialiserBoxsForGRRT();///////////////////////////////////////////////////////////////////////////////////////
		BoiteLimites();///////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		}      
		SearchfctPotentielLimte();
		if(kNbreOfvertex%252==0)BoiteLimites();
	}
	//else{}
}
void RRTBoxS::SearchfctPotentielLimte()
{
	int n=0;
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	struct box *l;/////////////////////////////////////////////////////////////////////////////////////////////////
	struct box *p;////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	l=this->Boxs;/////////////////////////////////////////////////////////////////////////////////////////////////
	//////4096////////////////////////////////////////////////////////////////////////////////////////////////////
	maxGRRT=RRTVertexe();/////////////////////////////////////////////////////////////////////////////////////////
	minGRRT=RRTVertexe();/////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	while(l!=NULL)
	{
		if(l->boiteLimite)
		{
			n++;
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			p=l;////////////////////////////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
			break;////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////////
		}
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		l=l->suivant;//////////////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if((p->boiteLimite)&&(p!=NULL))
	{
		////////////////////////////////////////////////////////////////////////////////////////////////////
		maxGRRT=(p->UpperVertex);////////////////////////////////////////////////////////////////a verifier
		minGRRT=(p->LowerVertex);///////////////////////////////////////////////////////////////a verifier
		p->boiteLimite=false;////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////
	}

}
void RRTBoxS::LocaliseSystem(double minvertX,double maxvertX,double minvertY,double maxvertY)
{
	RRTBoxS::box *l;
	l=this->Boxs;
	while(l!=NULL)
	{	
		if((l->UpperVertex.ConsultVertex()[0]>=minvertX)&&(l->LowerVertex.ConsultVertex()[0]<=maxvertX)&&(l->UpperVertex.ConsultVertex()[1]>=minvertY)&&(l->LowerVertex.ConsultVertex()[1]<=maxvertY))
			l->frontieres=true;
		else l->frontieres=false;
		l=l->suivant;
	}

}
/*void RRTBoxS::GeneralBoxsForKRRT(RRTTree::Vertexes *l,int kNbreOfvertex,RRTTree::Vertexes *Tre1,RRTTree::Vertexes *Tre2)
{
	if(kNbreOfvertex==1)
	{
		PartitionOfBoxs();
		CalculVolumeS();
		InitialiserBoxs();
	}
	CalculAstarPlusMoins(kNbreOfvertex);
	CalculMesureOfDiscrpence(l,kNbreOfvertex);
	StarDiscrepancy();
	CalculFonctionPotentielBeta();
	if(kNbreOfvertex%100==0)
	{
		CalculMesureOfDiparity(Tre1,Tre2);//tre 1 et tre 2
		CalculNouvelleMesure();
		SearchfctPotentielforKRRT();
	}
	else 
	{
		CalculNouvelleMesure();
		SearchfctPotentiel();
		this->maxKRRT=this->maxGRRT;
		this->minKRRT=this->minGRRT;
	}

}*/